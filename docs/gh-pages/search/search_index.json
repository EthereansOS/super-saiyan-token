{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"SuperSaiyanToken Super Saiya-jin Token is a ethItem Token Standard which includes capabilities to be used as a Voting Tokens for DFO. It is linked to a specific DFO through the Double Proxy, and every function that writes on the storage can be just triggered through a Proposal by the Token Holders of the linked DFO.","title":"Home"},{"location":"#supersaiyantoken","text":"Super Saiya-jin Token is a ethItem Token Standard which includes capabilities to be used as a Voting Tokens for DFO. It is linked to a specific DFO through the Double Proxy, and every function that writes on the storage can be just triggered through a Proposal by the Token Holders of the linked DFO.","title":"SuperSaiyanToken"},{"location":"out/DFOERC20NFTWrapper/","text":"Contract ISuperSaiyanToken Path: out/DFOERC20NFTWrapper.sol Version: 1 Title: SuperSaiyanToken Super Saiya-jin Token is a ethItem Token Standard which includes capabilities to be used as a Voting Tokens for DFO. It is linked to a specific DFO through the Double Proxy, and every funcion that writes on the storage can be just triggered through a Proposal by the Token Holders of the linked DFO. Methods balanceOf(address,uint256) Returns the amount of tokens of token type id owned by account . Requirements: - account cannot be the zero address. balanceOfBatch(address[],uint256[]) xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}. Requirements: - accounts and ids must have the same length. decimals(uint256) Returns the decimals of the given token id Params objectId : the id of the token whose decimals you want to know doubleProxy() GET the Double Proxy of the linked DFO isApprovedForAll(address,address) Returns true if operator is approved to transfer account 's tokens. See {setApprovalForAll}. name(uint256) Returns the name of the given token id Params objectId : the id of the token whose name you want to know onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a safeBatchTransferFrom after the balances have been updated. To accept the transfer(s), this must return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")) (i.e. 0xbc197c81, or its own function selector). Params data : Additional data with no specified format from : The address which previously owned the token ids : An array containing ids of each token being transferred (order and length must match values array) operator : The address which initiated the batch transfer (i.e. msg.sender) values : An array containing amounts of each token being transferred (order and length must match ids array) Returns _0 : bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")) if transfer is allowed onERC1155Received(address,address,uint256,uint256,bytes) Handles the receipt of a single ERC1155 token type. This function is called at the end of a safeTransferFrom after the balance has been updated. To accept the transfer, this must return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) (i.e. 0xf23a6e61, or its own function selector). Params data : Additional data with no specified format from : The address which previously owned the token id : The ID of the token being transferred operator : The address which initiated the transfer (i.e. msg.sender) value : The amount of tokens being transferred Returns _0 : bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) if transfer is allowed safeBatchTransferFrom(address,address,uint256[],uint256[],bytes) xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}. Emits a {TransferBatch} event. Requirements: - ids and amounts must have the same length. - If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value. safeTransferFrom(address,address,uint256,uint256,bytes) Transfers amount tokens of token type id from from to to . Emits a {TransferSingle} event. Requirements: - to cannot be the zero address. - If the caller is not from , it must be have been approved to spend from 's tokens via {setApprovalForAll}. - from must have a balance of tokens of type id of at least amount . - If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value. setApprovalForAll(address,bool) Grants or revokes permission to operator to transfer the caller's tokens, according to approved , Emits an {ApprovalForAll} event. Requirements: - operator cannot be the caller. setDoubleProxy(address) SET the Double Proxy of the linked DFO This function can be called just by voting a Proposal in the Linked DFO Params newDoubleProxy : represents the address of the new Double Proxy setUri(uint256,string) SET the URI to locate the Metadata of the Token Id passed in input This function can be called just by voting a Proposal in the Linked DFO It raises the 'UriChanged' event Params objectId : the Token Id whose Metadata uri to be set. uri : the new Metadata uri supportsInterface(bytes4) Returns true if this contract implements the interface defined by interfaceId . See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas. symbol(uint256) Returns the symbol of the given token id Params objectId : the id of the token whose symbol you want to know totalSupply(uint256) Returns the total supply of the given token id Params objectId : the id of the token whose availability you want to know uri(uint256) Returns the uri of the given token id Params objectId : the id of the token whose uri you want to know","title":"IERC1155Views"},{"location":"out/DFOERC20NFTWrapper/#contract-isupersaiyantoken","text":"Path: out/DFOERC20NFTWrapper.sol Version: 1 Title: SuperSaiyanToken Super Saiya-jin Token is a ethItem Token Standard which includes capabilities to be used as a Voting Tokens for DFO. It is linked to a specific DFO through the Double Proxy, and every funcion that writes on the storage can be just triggered through a Proposal by the Token Holders of the linked DFO.","title":"Contract ISuperSaiyanToken"},{"location":"out/DFOERC20NFTWrapper/#methods","text":"","title":"Methods"},{"location":"out/DFOERC20NFTWrapper/#balanceofaddressuint256","text":"Returns the amount of tokens of token type id owned by account . Requirements: - account cannot be the zero address.","title":"balanceOf(address,uint256)"},{"location":"out/DFOERC20NFTWrapper/#balanceofbatchaddressuint256","text":"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}. Requirements: - accounts and ids must have the same length.","title":"balanceOfBatch(address[],uint256[])"},{"location":"out/DFOERC20NFTWrapper/#decimalsuint256","text":"Returns the decimals of the given token id","title":"decimals(uint256)"},{"location":"out/DFOERC20NFTWrapper/#params","text":"objectId : the id of the token whose decimals you want to know","title":"Params"},{"location":"out/DFOERC20NFTWrapper/#doubleproxy","text":"GET the Double Proxy of the linked DFO","title":"doubleProxy()"},{"location":"out/DFOERC20NFTWrapper/#isapprovedforalladdressaddress","text":"Returns true if operator is approved to transfer account 's tokens. See {setApprovalForAll}.","title":"isApprovedForAll(address,address)"},{"location":"out/DFOERC20NFTWrapper/#nameuint256","text":"Returns the name of the given token id","title":"name(uint256)"},{"location":"out/DFOERC20NFTWrapper/#params_1","text":"objectId : the id of the token whose name you want to know","title":"Params"},{"location":"out/DFOERC20NFTWrapper/#onerc1155batchreceivedaddressaddressuint256uint256bytes","text":"Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a safeBatchTransferFrom after the balances have been updated. To accept the transfer(s), this must return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")) (i.e. 0xbc197c81, or its own function selector).","title":"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"},{"location":"out/DFOERC20NFTWrapper/#params_2","text":"data : Additional data with no specified format from : The address which previously owned the token ids : An array containing ids of each token being transferred (order and length must match values array) operator : The address which initiated the batch transfer (i.e. msg.sender) values : An array containing amounts of each token being transferred (order and length must match ids array)","title":"Params"},{"location":"out/DFOERC20NFTWrapper/#returns","text":"_0 : bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")) if transfer is allowed","title":"Returns"},{"location":"out/DFOERC20NFTWrapper/#onerc1155receivedaddressaddressuint256uint256bytes","text":"Handles the receipt of a single ERC1155 token type. This function is called at the end of a safeTransferFrom after the balance has been updated. To accept the transfer, this must return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) (i.e. 0xf23a6e61, or its own function selector).","title":"onERC1155Received(address,address,uint256,uint256,bytes)"},{"location":"out/DFOERC20NFTWrapper/#params_3","text":"data : Additional data with no specified format from : The address which previously owned the token id : The ID of the token being transferred operator : The address which initiated the transfer (i.e. msg.sender) value : The amount of tokens being transferred","title":"Params"},{"location":"out/DFOERC20NFTWrapper/#returns_1","text":"_0 : bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) if transfer is allowed","title":"Returns"},{"location":"out/DFOERC20NFTWrapper/#safebatchtransferfromaddressaddressuint256uint256bytes","text":"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}. Emits a {TransferBatch} event. Requirements: - ids and amounts must have the same length. - If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.","title":"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)"},{"location":"out/DFOERC20NFTWrapper/#safetransferfromaddressaddressuint256uint256bytes","text":"Transfers amount tokens of token type id from from to to . Emits a {TransferSingle} event. Requirements: - to cannot be the zero address. - If the caller is not from , it must be have been approved to spend from 's tokens via {setApprovalForAll}. - from must have a balance of tokens of type id of at least amount . - If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value.","title":"safeTransferFrom(address,address,uint256,uint256,bytes)"},{"location":"out/DFOERC20NFTWrapper/#setapprovalforalladdressbool","text":"Grants or revokes permission to operator to transfer the caller's tokens, according to approved , Emits an {ApprovalForAll} event. Requirements: - operator cannot be the caller.","title":"setApprovalForAll(address,bool)"},{"location":"out/DFOERC20NFTWrapper/#setdoubleproxyaddress","text":"SET the Double Proxy of the linked DFO This function can be called just by voting a Proposal in the Linked DFO","title":"setDoubleProxy(address)"},{"location":"out/DFOERC20NFTWrapper/#params_4","text":"newDoubleProxy : represents the address of the new Double Proxy","title":"Params"},{"location":"out/DFOERC20NFTWrapper/#seturiuint256string","text":"SET the URI to locate the Metadata of the Token Id passed in input This function can be called just by voting a Proposal in the Linked DFO It raises the 'UriChanged' event","title":"setUri(uint256,string)"},{"location":"out/DFOERC20NFTWrapper/#params_5","text":"objectId : the Token Id whose Metadata uri to be set. uri : the new Metadata uri","title":"Params"},{"location":"out/DFOERC20NFTWrapper/#supportsinterfacebytes4","text":"Returns true if this contract implements the interface defined by interfaceId . See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.","title":"supportsInterface(bytes4)"},{"location":"out/DFOERC20NFTWrapper/#symboluint256","text":"Returns the symbol of the given token id","title":"symbol(uint256)"},{"location":"out/DFOERC20NFTWrapper/#params_6","text":"objectId : the id of the token whose symbol you want to know","title":"Params"},{"location":"out/DFOERC20NFTWrapper/#totalsupplyuint256","text":"Returns the total supply of the given token id","title":"totalSupply(uint256)"},{"location":"out/DFOERC20NFTWrapper/#params_7","text":"objectId : the id of the token whose availability you want to know","title":"Params"},{"location":"out/DFOERC20NFTWrapper/#uriuint256","text":"Returns the uri of the given token id","title":"uri(uint256)"},{"location":"out/DFOERC20NFTWrapper/#params_8","text":"objectId : the id of the token whose uri you want to know","title":"Params"},{"location":"out/IDFOERC20NFTWrapper/","text":"Contract IDFOERC20NFTWrapper Path: out/IDFOERC20NFTWrapper.sol Version: 1 Title: IDFOERC20NFTWrapper This ERC20 Token represents the model of every Super Saiya-jin Token will implement for every minted NFT It just implements the same funcions of the VotingToken of the DFOProtocol, to let it became a Voting Token Methods allowance(address,address) Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called. approve(address,uint256) Sets amount as the allowance of spender over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event. balanceOf(address) Returns the amount of tokens owned by account . getProxy() GET the Proxy mint(uint256) Mint functionality of the voting token setProxy() SET the Proxy totalSupply() Returns the amount of tokens in existence. transfer(address,uint256) Moves amount tokens from the caller's account to recipient . Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event. transferFrom(address,address,uint256) Moves amount tokens from sender to recipient using the allowance mechanism. amount is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.","title":"IDFOERC20NFTWrapper"},{"location":"out/IDFOERC20NFTWrapper/#contract-idfoerc20nftwrapper","text":"Path: out/IDFOERC20NFTWrapper.sol Version: 1 Title: IDFOERC20NFTWrapper This ERC20 Token represents the model of every Super Saiya-jin Token will implement for every minted NFT It just implements the same funcions of the VotingToken of the DFOProtocol, to let it became a Voting Token","title":"Contract IDFOERC20NFTWrapper"},{"location":"out/IDFOERC20NFTWrapper/#methods","text":"","title":"Methods"},{"location":"out/IDFOERC20NFTWrapper/#allowanceaddressaddress","text":"Returns the remaining number of tokens that spender will be allowed to spend on behalf of owner through {transferFrom}. This is zero by default. This value changes when {approve} or {transferFrom} are called.","title":"allowance(address,address)"},{"location":"out/IDFOERC20NFTWrapper/#approveaddressuint256","text":"Sets amount as the allowance of spender over the caller's tokens. Returns a boolean value indicating whether the operation succeeded. IMPORTANT: Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 Emits an {Approval} event.","title":"approve(address,uint256)"},{"location":"out/IDFOERC20NFTWrapper/#balanceofaddress","text":"Returns the amount of tokens owned by account .","title":"balanceOf(address)"},{"location":"out/IDFOERC20NFTWrapper/#getproxy","text":"GET the Proxy","title":"getProxy()"},{"location":"out/IDFOERC20NFTWrapper/#mintuint256","text":"Mint functionality of the voting token","title":"mint(uint256)"},{"location":"out/IDFOERC20NFTWrapper/#setproxy","text":"SET the Proxy","title":"setProxy()"},{"location":"out/IDFOERC20NFTWrapper/#totalsupply","text":"Returns the amount of tokens in existence.","title":"totalSupply()"},{"location":"out/IDFOERC20NFTWrapper/#transferaddressuint256","text":"Moves amount tokens from the caller's account to recipient . Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.","title":"transfer(address,uint256)"},{"location":"out/IDFOERC20NFTWrapper/#transferfromaddressaddressuint256","text":"Moves amount tokens from sender to recipient using the allowance mechanism. amount is then deducted from the caller's allowance. Returns a boolean value indicating whether the operation succeeded. Emits a {Transfer} event.","title":"transferFrom(address,address,uint256)"},{"location":"out/ISuperSaiyanToken/","text":"Contract ISuperSaiyanToken Path: out/ISuperSaiyanToken.sol Version: 1 Title: SuperSaiyanToken Super Saiya-jin Token is a ethItem Token Standard which includes capabilities to be used as a Voting Tokens for DFO. It is linked to a specific DFO through the Double Proxy, and every funcion that writes on the storage can be just triggered through a Proposal by the Token Holders of the linked DFO. Methods balanceOf(address,uint256) Returns the amount of tokens of token type id owned by account . Requirements: - account cannot be the zero address. balanceOfBatch(address[],uint256[]) xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}. Requirements: - accounts and ids must have the same length. decimals(uint256) Returns the decimals of the given token id Params objectId : the id of the token whose decimals you want to know doubleProxy() GET the Double Proxy of the linked DFO isApprovedForAll(address,address) Returns true if operator is approved to transfer account 's tokens. See {setApprovalForAll}. name(uint256) Returns the name of the given token id Params objectId : the id of the token whose name you want to know onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a safeBatchTransferFrom after the balances have been updated. To accept the transfer(s), this must return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")) (i.e. 0xbc197c81, or its own function selector). Params data : Additional data with no specified format from : The address which previously owned the token ids : An array containing ids of each token being transferred (order and length must match values array) operator : The address which initiated the batch transfer (i.e. msg.sender) values : An array containing amounts of each token being transferred (order and length must match ids array) Returns _0 : bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")) if transfer is allowed onERC1155Received(address,address,uint256,uint256,bytes) Handles the receipt of a single ERC1155 token type. This function is called at the end of a safeTransferFrom after the balance has been updated. To accept the transfer, this must return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) (i.e. 0xf23a6e61, or its own function selector). Params data : Additional data with no specified format from : The address which previously owned the token id : The ID of the token being transferred operator : The address which initiated the transfer (i.e. msg.sender) value : The amount of tokens being transferred Returns _0 : bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) if transfer is allowed safeBatchTransferFrom(address,address,uint256[],uint256[],bytes) xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}. Emits a {TransferBatch} event. Requirements: - ids and amounts must have the same length. - If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value. safeTransferFrom(address,address,uint256,uint256,bytes) Transfers amount tokens of token type id from from to to . Emits a {TransferSingle} event. Requirements: - to cannot be the zero address. - If the caller is not from , it must be have been approved to spend from 's tokens via {setApprovalForAll}. - from must have a balance of tokens of type id of at least amount . - If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value. setApprovalForAll(address,bool) Grants or revokes permission to operator to transfer the caller's tokens, according to approved , Emits an {ApprovalForAll} event. Requirements: - operator cannot be the caller. setDoubleProxy(address) SET the Double Proxy of the linked DFO This function can be called just by voting a Proposal in the Linked DFO Params newDoubleProxy : represents the address of the new Double Proxy setUri(uint256,string) SET the URI to locate the Metadata of the Token Id passed in input This function can be called just by voting a Proposal in the Linked DFO It raises the 'UriChanged' event Params objectId : the Token Id whose Metadata uri to be set. uri : the new Metadata uri supportsInterface(bytes4) Returns true if this contract implements the interface defined by interfaceId . See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas. symbol(uint256) Returns the symbol of the given token id Params objectId : the id of the token whose symbol you want to know totalSupply(uint256) Returns the total supply of the given token id Params objectId : the id of the token whose availability you want to know uri(uint256) Returns the uri of the given token id Params objectId : the id of the token whose uri you want to know","title":"ISuperSaiyanToken"},{"location":"out/ISuperSaiyanToken/#contract-isupersaiyantoken","text":"Path: out/ISuperSaiyanToken.sol Version: 1 Title: SuperSaiyanToken Super Saiya-jin Token is a ethItem Token Standard which includes capabilities to be used as a Voting Tokens for DFO. It is linked to a specific DFO through the Double Proxy, and every funcion that writes on the storage can be just triggered through a Proposal by the Token Holders of the linked DFO.","title":"Contract ISuperSaiyanToken"},{"location":"out/ISuperSaiyanToken/#methods","text":"","title":"Methods"},{"location":"out/ISuperSaiyanToken/#balanceofaddressuint256","text":"Returns the amount of tokens of token type id owned by account . Requirements: - account cannot be the zero address.","title":"balanceOf(address,uint256)"},{"location":"out/ISuperSaiyanToken/#balanceofbatchaddressuint256","text":"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}. Requirements: - accounts and ids must have the same length.","title":"balanceOfBatch(address[],uint256[])"},{"location":"out/ISuperSaiyanToken/#decimalsuint256","text":"Returns the decimals of the given token id","title":"decimals(uint256)"},{"location":"out/ISuperSaiyanToken/#params","text":"objectId : the id of the token whose decimals you want to know","title":"Params"},{"location":"out/ISuperSaiyanToken/#doubleproxy","text":"GET the Double Proxy of the linked DFO","title":"doubleProxy()"},{"location":"out/ISuperSaiyanToken/#isapprovedforalladdressaddress","text":"Returns true if operator is approved to transfer account 's tokens. See {setApprovalForAll}.","title":"isApprovedForAll(address,address)"},{"location":"out/ISuperSaiyanToken/#nameuint256","text":"Returns the name of the given token id","title":"name(uint256)"},{"location":"out/ISuperSaiyanToken/#params_1","text":"objectId : the id of the token whose name you want to know","title":"Params"},{"location":"out/ISuperSaiyanToken/#onerc1155batchreceivedaddressaddressuint256uint256bytes","text":"Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a safeBatchTransferFrom after the balances have been updated. To accept the transfer(s), this must return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")) (i.e. 0xbc197c81, or its own function selector).","title":"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"},{"location":"out/ISuperSaiyanToken/#params_2","text":"data : Additional data with no specified format from : The address which previously owned the token ids : An array containing ids of each token being transferred (order and length must match values array) operator : The address which initiated the batch transfer (i.e. msg.sender) values : An array containing amounts of each token being transferred (order and length must match ids array)","title":"Params"},{"location":"out/ISuperSaiyanToken/#returns","text":"_0 : bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")) if transfer is allowed","title":"Returns"},{"location":"out/ISuperSaiyanToken/#onerc1155receivedaddressaddressuint256uint256bytes","text":"Handles the receipt of a single ERC1155 token type. This function is called at the end of a safeTransferFrom after the balance has been updated. To accept the transfer, this must return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) (i.e. 0xf23a6e61, or its own function selector).","title":"onERC1155Received(address,address,uint256,uint256,bytes)"},{"location":"out/ISuperSaiyanToken/#params_3","text":"data : Additional data with no specified format from : The address which previously owned the token id : The ID of the token being transferred operator : The address which initiated the transfer (i.e. msg.sender) value : The amount of tokens being transferred","title":"Params"},{"location":"out/ISuperSaiyanToken/#returns_1","text":"_0 : bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) if transfer is allowed","title":"Returns"},{"location":"out/ISuperSaiyanToken/#safebatchtransferfromaddressaddressuint256uint256bytes","text":"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}. Emits a {TransferBatch} event. Requirements: - ids and amounts must have the same length. - If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.","title":"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)"},{"location":"out/ISuperSaiyanToken/#safetransferfromaddressaddressuint256uint256bytes","text":"Transfers amount tokens of token type id from from to to . Emits a {TransferSingle} event. Requirements: - to cannot be the zero address. - If the caller is not from , it must be have been approved to spend from 's tokens via {setApprovalForAll}. - from must have a balance of tokens of type id of at least amount . - If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value.","title":"safeTransferFrom(address,address,uint256,uint256,bytes)"},{"location":"out/ISuperSaiyanToken/#setapprovalforalladdressbool","text":"Grants or revokes permission to operator to transfer the caller's tokens, according to approved , Emits an {ApprovalForAll} event. Requirements: - operator cannot be the caller.","title":"setApprovalForAll(address,bool)"},{"location":"out/ISuperSaiyanToken/#setdoubleproxyaddress","text":"SET the Double Proxy of the linked DFO This function can be called just by voting a Proposal in the Linked DFO","title":"setDoubleProxy(address)"},{"location":"out/ISuperSaiyanToken/#params_4","text":"newDoubleProxy : represents the address of the new Double Proxy","title":"Params"},{"location":"out/ISuperSaiyanToken/#seturiuint256string","text":"SET the URI to locate the Metadata of the Token Id passed in input This function can be called just by voting a Proposal in the Linked DFO It raises the 'UriChanged' event","title":"setUri(uint256,string)"},{"location":"out/ISuperSaiyanToken/#params_5","text":"objectId : the Token Id whose Metadata uri to be set. uri : the new Metadata uri","title":"Params"},{"location":"out/ISuperSaiyanToken/#supportsinterfacebytes4","text":"Returns true if this contract implements the interface defined by interfaceId . See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.","title":"supportsInterface(bytes4)"},{"location":"out/ISuperSaiyanToken/#symboluint256","text":"Returns the symbol of the given token id","title":"symbol(uint256)"},{"location":"out/ISuperSaiyanToken/#params_6","text":"objectId : the id of the token whose symbol you want to know","title":"Params"},{"location":"out/ISuperSaiyanToken/#totalsupplyuint256","text":"Returns the total supply of the given token id","title":"totalSupply(uint256)"},{"location":"out/ISuperSaiyanToken/#params_7","text":"objectId : the id of the token whose availability you want to know","title":"Params"},{"location":"out/ISuperSaiyanToken/#uriuint256","text":"Returns the uri of the given token id","title":"uri(uint256)"},{"location":"out/ISuperSaiyanToken/#params_8","text":"objectId : the id of the token whose uri you want to know","title":"Params"},{"location":"out/SuperSaiyanToken/","text":"Contract ISuperSaiyanToken Path: out/SuperSaiyanToken.sol Version: 1 Title: SuperSaiyanToken Super Saiya-jin Token is a ethItem Token Standard which includes capabilities to be used as a Voting Tokens for DFO. It is linked to a specific DFO through the Double Proxy, and every funcion that writes on the storage can be just triggered through a Proposal by the Token Holders of the linked DFO. Methods balanceOf(address,uint256) Returns the amount of tokens of token type id owned by account . Requirements: - account cannot be the zero address. balanceOfBatch(address[],uint256[]) xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}. Requirements: - accounts and ids must have the same length. decimals(uint256) Returns the decimals of the given token id Params objectId : the id of the token whose decimals you want to know doubleProxy() GET the Double Proxy of the linked DFO isApprovedForAll(address,address) Returns true if operator is approved to transfer account 's tokens. See {setApprovalForAll}. name(uint256) Returns the name of the given token id Params objectId : the id of the token whose name you want to know onERC1155BatchReceived(address,address,uint256[],uint256[],bytes) Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a safeBatchTransferFrom after the balances have been updated. To accept the transfer(s), this must return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")) (i.e. 0xbc197c81, or its own function selector). Params data : Additional data with no specified format from : The address which previously owned the token ids : An array containing ids of each token being transferred (order and length must match values array) operator : The address which initiated the batch transfer (i.e. msg.sender) values : An array containing amounts of each token being transferred (order and length must match ids array) Returns _0 : bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")) if transfer is allowed onERC1155Received(address,address,uint256,uint256,bytes) Handles the receipt of a single ERC1155 token type. This function is called at the end of a safeTransferFrom after the balance has been updated. To accept the transfer, this must return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) (i.e. 0xf23a6e61, or its own function selector). Params data : Additional data with no specified format from : The address which previously owned the token id : The ID of the token being transferred operator : The address which initiated the transfer (i.e. msg.sender) value : The amount of tokens being transferred Returns _0 : bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) if transfer is allowed safeBatchTransferFrom(address,address,uint256[],uint256[],bytes) xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}. Emits a {TransferBatch} event. Requirements: - ids and amounts must have the same length. - If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value. safeTransferFrom(address,address,uint256,uint256,bytes) Transfers amount tokens of token type id from from to to . Emits a {TransferSingle} event. Requirements: - to cannot be the zero address. - If the caller is not from , it must be have been approved to spend from 's tokens via {setApprovalForAll}. - from must have a balance of tokens of type id of at least amount . - If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value. setApprovalForAll(address,bool) Grants or revokes permission to operator to transfer the caller's tokens, according to approved , Emits an {ApprovalForAll} event. Requirements: - operator cannot be the caller. setDoubleProxy(address) SET the Double Proxy of the linked DFO This function can be called just by voting a Proposal in the Linked DFO Params newDoubleProxy : represents the address of the new Double Proxy setUri(uint256,string) SET the URI to locate the Metadata of the Token Id passed in input This function can be called just by voting a Proposal in the Linked DFO It raises the 'UriChanged' event Params objectId : the Token Id whose Metadata uri to be set. uri : the new Metadata uri supportsInterface(bytes4) Returns true if this contract implements the interface defined by interfaceId . See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas. symbol(uint256) Returns the symbol of the given token id Params objectId : the id of the token whose symbol you want to know totalSupply(uint256) Returns the total supply of the given token id Params objectId : the id of the token whose availability you want to know uri(uint256) Returns the uri of the given token id Params objectId : the id of the token whose uri you want to know","title":"SuperSaiyanToken"},{"location":"out/SuperSaiyanToken/#contract-isupersaiyantoken","text":"Path: out/SuperSaiyanToken.sol Version: 1 Title: SuperSaiyanToken Super Saiya-jin Token is a ethItem Token Standard which includes capabilities to be used as a Voting Tokens for DFO. It is linked to a specific DFO through the Double Proxy, and every funcion that writes on the storage can be just triggered through a Proposal by the Token Holders of the linked DFO.","title":"Contract ISuperSaiyanToken"},{"location":"out/SuperSaiyanToken/#methods","text":"","title":"Methods"},{"location":"out/SuperSaiyanToken/#balanceofaddressuint256","text":"Returns the amount of tokens of token type id owned by account . Requirements: - account cannot be the zero address.","title":"balanceOf(address,uint256)"},{"location":"out/SuperSaiyanToken/#balanceofbatchaddressuint256","text":"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}. Requirements: - accounts and ids must have the same length.","title":"balanceOfBatch(address[],uint256[])"},{"location":"out/SuperSaiyanToken/#decimalsuint256","text":"Returns the decimals of the given token id","title":"decimals(uint256)"},{"location":"out/SuperSaiyanToken/#params","text":"objectId : the id of the token whose decimals you want to know","title":"Params"},{"location":"out/SuperSaiyanToken/#doubleproxy","text":"GET the Double Proxy of the linked DFO","title":"doubleProxy()"},{"location":"out/SuperSaiyanToken/#isapprovedforalladdressaddress","text":"Returns true if operator is approved to transfer account 's tokens. See {setApprovalForAll}.","title":"isApprovedForAll(address,address)"},{"location":"out/SuperSaiyanToken/#nameuint256","text":"Returns the name of the given token id","title":"name(uint256)"},{"location":"out/SuperSaiyanToken/#params_1","text":"objectId : the id of the token whose name you want to know","title":"Params"},{"location":"out/SuperSaiyanToken/#onerc1155batchreceivedaddressaddressuint256uint256bytes","text":"Handles the receipt of a multiple ERC1155 token types. This function is called at the end of a safeBatchTransferFrom after the balances have been updated. To accept the transfer(s), this must return bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")) (i.e. 0xbc197c81, or its own function selector).","title":"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)"},{"location":"out/SuperSaiyanToken/#params_2","text":"data : Additional data with no specified format from : The address which previously owned the token ids : An array containing ids of each token being transferred (order and length must match values array) operator : The address which initiated the batch transfer (i.e. msg.sender) values : An array containing amounts of each token being transferred (order and length must match ids array)","title":"Params"},{"location":"out/SuperSaiyanToken/#returns","text":"_0 : bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\")) if transfer is allowed","title":"Returns"},{"location":"out/SuperSaiyanToken/#onerc1155receivedaddressaddressuint256uint256bytes","text":"Handles the receipt of a single ERC1155 token type. This function is called at the end of a safeTransferFrom after the balance has been updated. To accept the transfer, this must return bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) (i.e. 0xf23a6e61, or its own function selector).","title":"onERC1155Received(address,address,uint256,uint256,bytes)"},{"location":"out/SuperSaiyanToken/#params_3","text":"data : Additional data with no specified format from : The address which previously owned the token id : The ID of the token being transferred operator : The address which initiated the transfer (i.e. msg.sender) value : The amount of tokens being transferred","title":"Params"},{"location":"out/SuperSaiyanToken/#returns_1","text":"_0 : bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\")) if transfer is allowed","title":"Returns"},{"location":"out/SuperSaiyanToken/#safebatchtransferfromaddressaddressuint256uint256bytes","text":"xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}. Emits a {TransferBatch} event. Requirements: - ids and amounts must have the same length. - If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the acceptance magic value.","title":"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)"},{"location":"out/SuperSaiyanToken/#safetransferfromaddressaddressuint256uint256bytes","text":"Transfers amount tokens of token type id from from to to . Emits a {TransferSingle} event. Requirements: - to cannot be the zero address. - If the caller is not from , it must be have been approved to spend from 's tokens via {setApprovalForAll}. - from must have a balance of tokens of type id of at least amount . - If to refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the acceptance magic value.","title":"safeTransferFrom(address,address,uint256,uint256,bytes)"},{"location":"out/SuperSaiyanToken/#setapprovalforalladdressbool","text":"Grants or revokes permission to operator to transfer the caller's tokens, according to approved , Emits an {ApprovalForAll} event. Requirements: - operator cannot be the caller.","title":"setApprovalForAll(address,bool)"},{"location":"out/SuperSaiyanToken/#setdoubleproxyaddress","text":"SET the Double Proxy of the linked DFO This function can be called just by voting a Proposal in the Linked DFO","title":"setDoubleProxy(address)"},{"location":"out/SuperSaiyanToken/#params_4","text":"newDoubleProxy : represents the address of the new Double Proxy","title":"Params"},{"location":"out/SuperSaiyanToken/#seturiuint256string","text":"SET the URI to locate the Metadata of the Token Id passed in input This function can be called just by voting a Proposal in the Linked DFO It raises the 'UriChanged' event","title":"setUri(uint256,string)"},{"location":"out/SuperSaiyanToken/#params_5","text":"objectId : the Token Id whose Metadata uri to be set. uri : the new Metadata uri","title":"Params"},{"location":"out/SuperSaiyanToken/#supportsinterfacebytes4","text":"Returns true if this contract implements the interface defined by interfaceId . See the corresponding https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section] to learn more about how these ids are created. This function call must use less than 30 000 gas.","title":"supportsInterface(bytes4)"},{"location":"out/SuperSaiyanToken/#symboluint256","text":"Returns the symbol of the given token id","title":"symbol(uint256)"},{"location":"out/SuperSaiyanToken/#params_6","text":"objectId : the id of the token whose symbol you want to know","title":"Params"},{"location":"out/SuperSaiyanToken/#totalsupplyuint256","text":"Returns the total supply of the given token id","title":"totalSupply(uint256)"},{"location":"out/SuperSaiyanToken/#params_7","text":"objectId : the id of the token whose availability you want to know","title":"Params"},{"location":"out/SuperSaiyanToken/#uriuint256","text":"Returns the uri of the given token id","title":"uri(uint256)"},{"location":"out/SuperSaiyanToken/#params_8","text":"objectId : the id of the token whose uri you want to know","title":"Params"}]}